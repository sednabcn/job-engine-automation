name: Cleanup Workflow Runs Aggressively

on:
  push:
    branches: ["master"]
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    
    steps:
      - name: üßπ Delete old workflow runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üîß CONFIGURATION
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            const KEEP_DAYS = 1;              // Keep runs from last 1 day
            const KEEP_SUCCESSFUL = 2;        // Keep 2 successful per workflow
            const DELETE_FAILED = true;       // Delete old failed runs
            const DELETE_CANCELLED = true;    // Delete old cancelled runs
            const SLEEP_MS = 100;             // Delay between API calls
            const DRY_RUN = false;            // Set true to preview only
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            console.log('\n' + '‚ïê'.repeat(80));
            console.log('üßπ WORKFLOW CLEANUP STARTED');
            console.log('‚ïê'.repeat(80));
            console.log(`üì¶ Repository: ${owner}/${repo}`);
            console.log(`üìÖ Keep: ${KEEP_DAYS} day(s), ${KEEP_SUCCESSFUL} successful/workflow`);
            console.log(`‚ùå Delete failed: ${DELETE_FAILED}, cancelled: ${DELETE_CANCELLED}`);
            if (DRY_RUN) console.log('‚ö†Ô∏è  DRY RUN - Nothing will be deleted');
            console.log('‚ïê'.repeat(80) + '\n');
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);
            console.log(`üóìÔ∏è  Cutoff: ${cutoffDate.toISOString()}\n`);
            
            // Fetch workflows
            let workflows;
            try {
              workflows = await github.paginate(
                github.rest.actions.listRepoWorkflows,
                { owner, repo, per_page: 100 }
              );
            } catch (error) {
              console.log(`‚ùå Failed to fetch workflows: ${error.message}`);
              return;
            }
            
            console.log(`üìã Found ${workflows.length} workflows\n`);
            
            let totalDeleted = 0;
            let totalKept = 0;
            let totalErrors = 0;
            
            for (const workflow of workflows) {
              console.log('‚îÄ'.repeat(80));
              console.log(`üîç ${workflow.name}`);
              console.log(`   ID: ${workflow.id}`);
              console.log('‚îÄ'.repeat(80));
              
              let runs;
              try {
                runs = await github.paginate(
                  github.rest.actions.listWorkflowRuns,
                  { owner, repo, workflow_id: workflow.id, per_page: 100 }
                );
              } catch (error) {
                console.log(`   ‚ùå Error fetching runs: ${error.message}\n`);
                totalErrors++;
                continue;
              }
              
              if (!runs.length) {
                console.log(`   ‚ÑπÔ∏è  No runs found\n`);
                continue;
              }
              
              runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              console.log(`   üìä Total runs: ${runs.length}`);
              
              const runsToDelete = [];
              const runsToKeep = [];
              let successfulKept = 0;
              
              for (const run of runs) {
                const runDate = new Date(run.created_at);
                const ageInDays = (Date.now() - runDate) / (1000 * 60 * 60 * 24);
                const isOld = runDate < cutoffDate;
                const conclusion = run.conclusion || 'in_progress';
                
                if (run.id === context.runId) {
                  runsToKeep.push({ run, reason: 'CURRENT' });
                  continue;
                }
                
                if (conclusion === 'success') {
                  successfulKept++;
                  if (successfulKept <= KEEP_SUCCESSFUL) {
                    runsToKeep.push({ run, reason: `SUCCESS #${successfulKept}` });
                  } else if (!isOld) {
                    runsToKeep.push({ run, reason: `RECENT (${ageInDays.toFixed(1)}d)` });
                  } else {
                    runsToDelete.push({ 
                      run, 
                      reason: `OLD SUCCESS (${ageInDays.toFixed(1)}d)` 
                    });
                  }
                }
                else if (conclusion === 'failure' && DELETE_FAILED) {
                  if (isOld) {
                    runsToDelete.push({ run, reason: `FAILED (${ageInDays.toFixed(1)}d old)` });
                  } else {
                    runsToKeep.push({ run, reason: `FAILED BUT RECENT` });
                  }
                }
                else if (conclusion === 'cancelled' && DELETE_CANCELLED) {
                  if (isOld) {
                    runsToDelete.push({ run, reason: `CANCELLED (${ageInDays.toFixed(1)}d old)` });
                  } else {
                    runsToKeep.push({ run, reason: `CANCELLED BUT RECENT` });
                  }
                }
                else if (!isOld) {
                  runsToKeep.push({ run, reason: `RECENT ${conclusion}` });
                } else {
                  runsToDelete.push({ run, reason: `OLD ${conclusion} (${ageInDays.toFixed(1)}d)` });
                }
              }
              
              console.log(`   üìä To Delete: ${runsToDelete.length} | To Keep: ${runsToKeep.length}`);
              
              if (runsToDelete.length > 0) {
                console.log(`   üóëÔ∏è  Deleting:`);
                for (const { run, reason } of runsToDelete.slice(0, 3)) {
                  const date = new Date(run.created_at).toISOString().split('T')[0];
                  console.log(`      #${run.run_number} ${date} - ${reason}`);
                }
                if (runsToDelete.length > 3) {
                  console.log(`      ... and ${runsToDelete.length - 3} more`);
                }
              }
              
              if (!DRY_RUN) {
                for (const { run } of runsToDelete) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id });
                    totalDeleted++;
                    if (totalDeleted % 10 === 0) {
                      console.log(`      ‚úì Deleted ${totalDeleted} runs...`);
                    }
                    await new Promise(r => setTimeout(r, SLEEP_MS));
                  } catch (err) {
                    console.log(`      ‚ùå Failed #${run.run_number}: ${err.message}`);
                    totalErrors++;
                  }
                }
              }
              
              totalKept += runsToKeep.length;
              console.log('');
            }
            
            console.log('‚ïê'.repeat(80));
            console.log('‚úÖ CLEANUP COMPLETE');
            console.log('‚ïê'.repeat(80));
            console.log(`üìä Statistics:`);
            console.log(`   ‚Ä¢ Deleted: ${totalDeleted}`);
            console.log(`   ‚Ä¢ Kept:    ${totalKept}`);
            console.log(`   ‚Ä¢ Errors:  ${totalErrors}`);
            if (DRY_RUN) {
              console.log(`\n‚ö†Ô∏è  DRY RUN - No runs were actually deleted`);
            }
            console.log('‚ïê'.repeat(80));
